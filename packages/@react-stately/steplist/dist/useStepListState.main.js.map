{"mappings":"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","sources":["packages/@react-stately/steplist/src/useStepListState.ts"],"sourcesContent":["/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, CollectionBase, Key, Node, SingleSelection} from '@react-types/shared';\nimport {SingleSelectListState, useSingleSelectListState} from '@react-stately/list';\nimport {useCallback, useEffect, useMemo} from 'react';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface StepListProps<T> extends CollectionBase<T>, SingleSelection {\n  /** The key of the last completed step (controlled). */\n  lastCompletedStep?: Key,\n  /** The key of the initially last completed step (uncontrolled). */\n  defaultLastCompletedStep?: Key,\n  /** Callback for when the last completed step changes. */\n  onLastCompletedStepChange?: (key: Key | null) => void,\n  /** Whether the step list is disabled. Steps will not be focusable or interactive. */\n  isDisabled?: boolean,\n  /** Whether the step list is read only. Steps will be focusable but non-interactive. */\n  isReadOnly?: boolean\n}\n\nexport interface StepListState<T> extends SingleSelectListState<T> {\n  readonly lastCompletedStep?: Key,\n  setLastCompletedStep(key: Key): void,\n  isCompleted(key: Key): boolean,\n  isSelectable(key: Key): boolean\n}\n\nexport function useStepListState<T extends object>(props: StepListProps<T>): StepListState<T> {\n  let state = useSingleSelectListState<T>(props);\n\n  let [lastCompletedStep, setLastCompletedStep] = useControlledState<Key | null>(props.lastCompletedStep, props.defaultLastCompletedStep ?? null, props.onLastCompletedStepChange);\n  const {setSelectedKey: realSetSelectedKey, selectedKey, collection} = state;\n  const {indexMap, keysLinkedList} = useMemo(() => buildKeysMaps(collection), [collection]);\n  const selectedIdx = selectedKey != null ? indexMap.get(selectedKey) : 0;\n\n  const isCompleted = useCallback((step: Key | null | undefined) => {\n    if (step === undefined) {\n      return false;\n    }\n\n    return (step !== null &&\n      lastCompletedStep !== null &&\n      indexMap.has(step) &&\n      indexMap.has(lastCompletedStep) &&\n      indexMap.get(step)! <= indexMap.get(lastCompletedStep)!);\n  }, [indexMap, lastCompletedStep]);\n\n  const findDefaultSelectedKey = useCallback((collection: Collection<Node<T>> | null, disabledKeys: Set<Key>) => {\n    let selectedKey: Key | null = null;\n    if (collection && collection.size > 0) {\n      selectedKey = collection.getFirstKey();\n      // loop over keys until we find one that isn't completed or disabled and select that\n      while (selectedKey !== collection.getLastKey() && selectedKey && (disabledKeys.has(selectedKey) || isCompleted(selectedKey))) {\n        selectedKey = collection.getKeyAfter(selectedKey);\n      }\n    }\n\n    return selectedKey;\n  }, [isCompleted]);\n\n  useEffect(() => {\n    // Ensure a step is always selected (in case no selected key was specified or if selected item was deleted from collection)\n    let selectedKey: Key | null = state.selectedKey;\n    if (state.selectionManager.isEmpty || selectedKey == null || !state.collection.getItem(selectedKey)) {\n      selectedKey = findDefaultSelectedKey(state.collection, state.disabledKeys);\n      if (selectedKey !== null) {\n        state.selectionManager.replaceSelection(selectedKey);\n      }\n    }\n\n    if (state.selectionManager.focusedKey == null) {\n      state.selectionManager.setFocusedKey(selectedKey);\n    }\n\n    let lcs = (lastCompletedStep !== null ? indexMap.get(lastCompletedStep) : -1) ?? -1;\n    if (selectedIdx !== undefined && selectedIdx > 0 && selectedIdx > lcs + 1 && selectedKey !== null && keysLinkedList.has(selectedKey)) {\n      setLastCompletedStep(keysLinkedList.get(selectedKey)!);\n    }\n  });\n\n  function isSelectable(step: Key) {\n    if (props.isDisabled || state.disabledKeys.has(step) || props.isReadOnly) {\n      return false;\n    }\n\n    if (isCompleted(step)) {\n      return true;\n    }\n\n    const prevStep = keysLinkedList.get(step);\n    return isCompleted(prevStep) || step === state.collection.getFirstKey();\n  }\n\n  function setSelectedKey(key: Key) {\n    const prevKey = keysLinkedList.get(key);\n    if (prevKey && !isCompleted(prevKey)) {\n      setLastCompletedStep(prevKey);\n    }\n    realSetSelectedKey(key);\n  }\n\n  return {\n    ...state,\n    setSelectedKey,\n    setLastCompletedStep,\n    isCompleted,\n    isSelectable\n  };\n}\n\nfunction buildKeysMaps<T>(coll: Collection<Node<T>>) {\n  const indexMap = new Map<Key, number>();\n  const keysLinkedList = new Map<Key, Key | undefined>();\n  let i = 0;\n  let prev: Node<T> | undefined = undefined;\n  for (const item of coll) {\n    indexMap.set(item.key, i);\n    keysLinkedList.set(item.key, prev?.key);\n    prev = item;\n    i++;\n  }\n  return {\n    indexMap,\n    keysLinkedList\n  };\n}\n"],"names":[],"version":3,"file":"useStepListState.main.js.map"}