{"mappings":"ACsEe;EAAA;;;;EAAA;;;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAsBQ;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAoCR;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;;EAAA;;;;;EAqBI;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EA6BO;;;;EAuBP;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAwEK;;;;EAAA;;;;EAqBC;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;;EA4CoD;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;;;EAAA;;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EA0CjD;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;;AAtTb;EAAA;;;;EAAA;;;;;AAAA;EAAA;;;;;AAAA;EAAA;;;;;AAAA;EAAA;;;;;AAAA;EAAA;;;;;AAAA;EAAA;;;;;AAAA;EAAA;;;;;AAAA;;AAAA;EAAA;IA4Q8D;;;;IAAA;;;;IAAA;;;;IAAA;;;;IAAA;;;;;;AAzI1D;EAAA;IAAA;;;;IA6FM;;;;IAAA;;;;IAAA;;;;IAAA;;;;;;AArBD;;;;AA2GI;EAAA;IAAA","sources":["ac662f3d1cc9df76","packages/@react-spectrum/s2/src/Slider.tsx"],"sourcesContent":["@import \"08b0e2dddac244ec\";\n@import \"a216064bff7feb94\";\n@import \"0e026599f927ff3c\";\n@import \"1cb0b30bc0f5a958\";\n@import \"edc162e184e119d3\";\n@import \"b86a124969f6f615\";\n@import \"9b5953d83288c51e\";\n@import \"d1e50ca165bdf4c3\";\n@import \"da42e21b823e7a9c\";\n@import \"6f133df38f9a43ae\";\n@import \"5a00966d61027041\";\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Slider as AriaSlider,\n  SliderProps as AriaSliderProps,\n  ContextValue,\n  SliderOutput,\n  SliderThumb,\n  SliderTrack\n} from 'react-aria-components';\nimport {clamp} from '@react-aria/utils';\nimport {createContext, forwardRef, ReactNode, RefObject, useContext, useRef} from 'react';\nimport {field, fieldInput, getAllowedOverrides, StyleProps} from './style-utils' with {type: 'macro'};\nimport {FieldLabel} from './Field';\nimport {FocusableRef, FocusableRefValue, InputDOMProps, SpectrumLabelableProps} from '@react-types/shared';\nimport {focusRing, style} from '../style' with {type: 'macro'};\nimport {FormContext, useFormProps} from './Form';\nimport {mergeStyles} from '../style/runtime';\nimport {pressScale} from './pressScale';\nimport {useFocusableRef} from '@react-spectrum/utils';\nimport {useLocale, useNumberFormatter} from '@react-aria/i18n';\nimport {useSpectrumContextProps} from './useSpectrumContextProps';\n\nexport interface SliderBaseProps<T> extends Omit<AriaSliderProps<T>, 'children' | 'style' | 'className' | 'orientation'>, Omit<SpectrumLabelableProps, 'necessityIndicator' | 'isRequired'>, StyleProps {\n  children?: ReactNode,\n  /**\n   * The size of the Slider.\n   *\n   * @default 'M'\n   */\n  size?: 'S' | 'M' | 'L' | 'XL',\n  /**\n   * Whether the Slider should be displayed with an emphasized style.\n   */\n  isEmphasized?: boolean,\n  /**\n   * The style of the Slider's track.\n   *\n   * @default 'thin'\n   */\n  trackStyle?: 'thin' | 'thick', // TODO: add ramp\n  /**\n   * The style of the Slider's thumb.\n   *\n   * @default 'default'\n   */\n  thumbStyle?: 'default' | 'precise'\n  // TODO\n  // isEditable?: boolean,\n}\n\nexport interface SliderProps extends Omit<SliderBaseProps<number>, 'children'>, InputDOMProps {\n  /**\n   * The offset from which to start the fill.\n   */\n  fillOffset?: number\n}\n\nexport const SliderContext = createContext<ContextValue<SliderProps, FocusableRefValue<HTMLDivElement>>>(null);\n\nconst slider = style({\n  font: 'control',\n  alignItems: {\n    labelPosition: {\n      side: 'center'\n    }\n  },\n  color: {\n    default: 'neutral-subdued',\n    isDisabled: 'disabled'\n  },\n  columnGap: {\n    size: {\n      S: 16,\n      M: 16,\n      L: 20,\n      XL: 24\n    },\n    isInForm: 12\n  }\n}, getAllowedOverrides());\n\nconst labelContainer = style({\n  display: {\n    labelPosition: {\n      top: 'grid'\n    }\n  },\n  gridArea: 'label',\n  width: 'full',\n  gridTemplateAreas: {\n    labelPosition: {\n      top: ['label output']\n    }\n  },\n  gridTemplateColumns: {\n    labelPosition: {\n      top: [\n        '1fr auto'\n      ]\n    }\n  },\n  textAlign: {\n    labelPosition: {\n      side: {\n        labelAlign: {\n          start: 'start',\n          end: 'end'\n        }\n      }\n    }\n  },\n  '--field-gap': {\n    type: 'paddingBottom',\n    value: 0\n  }\n});\n\nconst output = style({\n  gridArea: 'output',\n  textAlign: {\n    labelPosition: {\n      top: {\n        direction: {\n          ltr: 'end',\n          rtl: 'start'\n        }\n      },\n      side: {\n        direction: {\n          ltr: 'start',\n          rtl: 'end'\n        },\n        isInForm: 'end'\n      }\n    }\n  }\n});\n\nexport let track = style({\n  gridArea: 'track',\n  position: 'relative',\n  width: 'full',\n  height: {\n    size: {\n      S: 24,\n      M: 32,\n      L: 40,\n      XL: 48\n    }\n  }\n});\n\nexport let thumbContainer = style({\n  size: {\n    size: {\n      S: 18,\n      M: 20,\n      L: 22,\n      XL: 24\n    }\n  },\n  display: 'inline-block',\n  position: 'absolute',\n  top: '[50%]'\n});\n\n// if precision thumb should have a smaller hit area, then remove this\nexport let thumbHitArea = style({\n  size: {\n    thumbStyle: {\n      default: {\n        size: {\n          S: 18,\n          M: 20,\n          L: 22,\n          XL: 24\n        }\n      },\n      precise: {\n        size: {\n          S: 20,\n          M: 22,\n          L: 24,\n          XL: 26\n        }\n      }\n    }\n  }\n});\n\nexport let thumb = style({\n  ...focusRing(),\n  display: 'inline-block',\n  boxSizing: 'border-box',\n  position: 'absolute',\n  top: '[50%]',\n  left: '[50%]',\n  transform: 'translateY(-50%) translateX(-50%)',\n  width: {\n    thumbStyle: {\n      default: {\n        size: {\n          S: 18,\n          M: 20,\n          L: 22,\n          XL: 24\n        }\n      },\n      precise: 6\n    }\n  },\n  height: {\n    thumbStyle: {\n      default: {\n        size: {\n          S: 18,\n          M: 20,\n          L: 22,\n          XL: 24\n        }\n      },\n      precise: {\n        size: {\n          S: 20,\n          M: 22,\n          L: 24,\n          XL: 26\n        }\n      }\n    }\n  },\n  borderRadius: 'full',\n  borderStyle: 'solid',\n  borderWidth: '[2px]',\n  borderColor: {\n    default: 'gray-800',\n    isHovered: 'gray-900',\n    isDragging: 'gray-900',\n    isDisabled: 'disabled',\n    forcedColors: {\n      isDisabled: 'GrayText'\n    }\n  },\n  backgroundColor: 'gray-25'\n});\n\nconst trackStyling = {\n  height: {\n    trackStyle: {\n      thin: 4,\n      thick: 16\n    }\n  },\n  top: '[50%]',\n  borderRadius: {\n    trackStyle: {\n      thin: 'lg',\n      thick: 'sm'\n    }\n  }\n} as const;\n\nexport let upperTrack = style({\n  ...trackStyling,\n  position: 'absolute',\n  backgroundColor: {\n    default: 'gray-300',\n    isDisabled: 'disabled'\n  },\n  translateY: '[-50%]',\n  width: 'full',\n  boxSizing: 'border-box',\n  borderStyle: 'solid',\n  borderWidth: '[.5px]',\n  borderColor: {\n    default: 'transparent',\n    forcedColors: {\n      default: 'ButtonText',\n      isDisabled: 'GrayText'\n    }\n  }\n});\n\nexport let filledTrack = style({\n  ...trackStyling,\n  position: 'absolute',\n  backgroundColor: {\n    default: 'gray-700',\n    isEmphasized: 'accent-900',\n    isDisabled: 'disabled',\n    forcedColors: {\n      default: 'Highlight',\n      isDisabled: 'GrayText'\n    }\n  },\n  boxSizing: 'border-box',\n  borderStyle: 'solid',\n  borderWidth: '[.5px]',\n  borderColor: {\n    default: 'transparent',\n    forcedColors: {\n      default: 'ButtonText',\n      isDisabled: 'GrayText'\n    }\n  },\n  translateY: '[-50%]'\n});\n\nexport function SliderBase<T extends number | number[]>(props: SliderBaseProps<T> & {sliderRef: RefObject<HTMLDivElement | null>}) {\n  let formContext = useContext(FormContext);\n  props = useFormProps(props);\n  let {\n    label,\n    labelPosition = 'top',\n    labelAlign = 'start',\n    size = 'M',\n    minValue = 0,\n    maxValue = 100,\n    formatOptions\n  } = props;\n  let formatter = useNumberFormatter(formatOptions);\n  let {direction} = useLocale();\n\n  return (\n    <AriaSlider\n      {...props}\n      ref={props.sliderRef}\n      className={renderProps => (props.UNSAFE_className || '') + mergeStyles(style(field())({labelPosition, isInForm: !!formContext}), slider({...renderProps, labelPosition, size, isInForm: !!formContext}, props.styles))}>\n      {({state}) => {\n        let maxLabelLength = Math.max([...formatter.format(minValue)].length, [...formatter.format(maxValue)].length);\n        switch (state.values.length) {\n          case 1:\n            break;\n          case 2:\n            // This should really use the NumberFormat#formatRange proposal...\n            // https://github.com/tc39/ecma402/issues/393\n            // https://github.com/tc39/proposal-intl-numberformat-v3#formatrange-ecma-402-393\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/formatRange\n            maxLabelLength = 3 + 2 * Math.max(\n              maxLabelLength,\n              [...formatter.format(minValue)].length, [...formatter.format(maxValue)].length\n            );\n            break;\n          default:\n            throw new Error('Only sliders with 1 or 2 handles are supported!');\n        }\n\n        let outputValue = (\n          <SliderOutput\n            style={{width: `${maxLabelLength}ch`, minWidth: `${maxLabelLength}ch`, fontVariantNumeric: 'tabular-nums'}}\n            className={output({direction, labelPosition, isInForm: !!formContext})}>\n            {({state}) =>\n              state.values.map((_, i) => state.getThumbValueLabel(i)).join(' – ')}\n          </SliderOutput>\n        );\n\n        return (\n          <>\n            <div className={labelContainer({labelPosition, labelAlign})}>\n              <FieldLabel\n                isDisabled={props.isDisabled}\n                size={props.size}\n                labelPosition={labelPosition}\n                labelAlign={labelAlign}\n                contextualHelp={props.contextualHelp}>\n                {label}\n              </FieldLabel>\n              {labelPosition === 'top' && outputValue}\n            </div>\n            <div className={style({...fieldInput(), display: 'inline-flex', alignItems: 'center', gap: {default: 16, size: {L: 20, XL: 24}}})({size})}>\n              {props.children}\n              {labelPosition === 'side' && outputValue}\n            </div>\n          </>\n        );\n      }}\n    </AriaSlider>\n  );\n}\n\nexport const Slider = /*#__PURE__*/ forwardRef(function Slider(props: SliderProps, ref: FocusableRef<HTMLDivElement>) {\n  [props, ref] = useSpectrumContextProps(props, ref, SliderContext);\n  let formContext = useContext(FormContext);\n  props = useFormProps(props);\n  let {\n    labelPosition = 'top',\n    size = 'M',\n    fillOffset,\n    isEmphasized,\n    trackStyle = 'thin',\n    thumbStyle = 'default'\n  } = props;\n  let thumbRef = useRef(null);\n  let inputRef = useRef(null); // TODO: need to pass inputRef to SliderThumb when we release the next version of RAC 1.3.0\n  let domRef = useFocusableRef(ref, inputRef);\n  let {direction} = useLocale();\n  let cssDirection = direction === 'rtl' ? 'right' : 'left';\n\n  return (\n    <SliderBase\n      {...props}\n      sliderRef={domRef}>\n      <SliderTrack\n        className={track({size, labelPosition, isInForm: !!formContext})}>\n        {({state, isDisabled}) => {\n\n          fillOffset = fillOffset !== undefined ? clamp(fillOffset, state.getThumbMinValue(0), state.getThumbMaxValue(0)) : state.getThumbMinValue(0);\n\n          let fillWidth = state.getThumbPercent(0) - state.getValuePercent(fillOffset);\n          let isRightOfOffset = fillWidth > 0;\n          let offset = isRightOfOffset ? state.getValuePercent(fillOffset) : state.getThumbPercent(0);\n\n          return (\n            <>\n              <div className={upperTrack({isDisabled, trackStyle})} />\n              <div style={{width: `${Math.abs(fillWidth) * 100}%`, [cssDirection]: `${offset * 100}%`}} className={filledTrack({isDisabled, isEmphasized, trackStyle})} />\n              <SliderThumb  className={thumbContainer} index={0} name={props.name} ref={thumbRef} style={(renderProps) => pressScale(thumbRef, {transform: 'translate(-50%, -50%)'})({...renderProps, isPressed: renderProps.isDragging})}>\n                {(renderProps) => (\n                  <div className={thumbHitArea({size})}>\n                    <div\n                      className={thumb({\n                        ...renderProps,\n                        size,\n                        thumbStyle\n                      })} />\n                  </div>\n                )}\n              </SliderThumb>\n            </>\n          );\n        }}\n      </SliderTrack>\n    </SliderBase>\n  );\n});\n"],"names":[],"version":3,"file":"Slider.css.map"}