{"mappings":"ACuFkB;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EA0BG;;;;EAYM;;;;EAAA;;;;EASC;;;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAMN;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAmDC;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAkBR;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAKG;;;;EAAA;;;;EAAA;;;;EAYa;;;;EAAA;;;;EAKnB;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAoBO;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;;;EAAA;;;;EAAA;;;;EASM;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;;;;;;;;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAqBb;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAKG;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAgBE;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAoGL;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAAA;;;;EAkGmB;;;;;AA7Zb;EAqDI;;;;EAAA;;;;EAkJP;;;;EAAA;;;;EAoHH;;;;;AA3TM;EAAA;;;;;AAAA;EAAA;;;;;AAAA;EAAA;;;;;AAAA;EAAA;;;;;AAAA;EAAA;;;;;AAAA;EAAA;;;;;AAAA;;AAAA;EAAA;IA+HA;;;;IAqCC;;;;IASM;;;;IAAA;;;;IAAA;;;;IA0BV;;;;;;AAlJO;EAAA;IAAA;;;;IAmDC;;;;IA+FR;;;;;;AA/FQ","sources":["7c22b67265d3212e","packages/@react-spectrum/s2/src/Menu.tsx"],"sourcesContent":["@import \"dc7300f7a31f6746\";\n@import \"ba4f3709c47b6f32\";\n@import \"188776d578edc2d4\";\n@import \"7542e2c368e43074\";\n@import \"a0ece4d15d51b6d1\";\n@import \"9190ed57f0ec543d\";\n@import \"7ea87ac6ab45824a\";\n@import \"8dd2ed15af634baa\";\n@import \"e1b788d5c243c1be\";\n@import \"227155bda7dda199\";\n@import \"9349097043636fe6\";\n@import \"329bb28fb4b64255\";\n@import \"fa4d0c98959eb626\";\n@import \"7ed629d8804e69a8\";\n@import \"c7f5b0af4e97a693\";\n@import \"04aee1e7a62e8b5b\";\n@import \"ddf352cdf38358b0\";\n","/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Menu as AriaMenu,\n  MenuItem as AriaMenuItem,\n  MenuItemProps as AriaMenuItemProps,\n  MenuProps as AriaMenuProps,\n  MenuSection as AriaMenuSection,\n  MenuSectionProps as AriaMenuSectionProps,\n  MenuTrigger as AriaMenuTrigger,\n  MenuTriggerProps as AriaMenuTriggerProps,\n  SubmenuTrigger as AriaSubmenuTrigger,\n  SubmenuTriggerProps as AriaSubmenuTriggerProps,\n  ContextValue,\n  Provider,\n  Separator,\n  SeparatorProps\n} from 'react-aria-components';\nimport {baseColor, edgeToText, focusRing, fontRelative, size, space, style} from '../style' with {type: 'macro'};\nimport {box, iconStyles} from './Checkbox';\nimport {centerBaseline} from './CenterBaseline';\nimport {centerPadding, getAllowedOverrides, StyleProps} from './style-utils' with {type: 'macro'};\nimport CheckmarkIcon from '../ui-icons/Checkmark';\nimport ChevronRightIcon from '../ui-icons/Chevron';\nimport {createContext, forwardRef, JSX, ReactNode, useContext, useRef} from 'react';\nimport {divider} from './Divider';\nimport {DOMRef, DOMRefValue} from '@react-types/shared';\nimport {forwardRefType} from './types';\nimport {HeaderContext, HeadingContext, KeyboardContext, Text, TextContext} from './Content';\nimport {IconContext} from './Icon'; // chevron right removed??\nimport {ImageContext} from './Image';\nimport LinkOutIcon from '../ui-icons/LinkOut';\nimport {mergeStyles} from '../style/runtime';\nimport {Placement, useLocale} from 'react-aria';\nimport {PopoverBase} from './Popover';\nimport {PressResponder} from '@react-aria/interactions';\nimport {pressScale} from './pressScale';\nimport {useSpectrumContextProps} from './useSpectrumContextProps';\n// viewbox on LinkOut is super weird just because i copied the icon from designs...\n// need to strip id's from icons\n\nexport interface MenuTriggerProps extends AriaMenuTriggerProps {\n  /**\n   * Alignment of the menu relative to the trigger.\n   *\n   * @default 'start'\n   */\n  align?: 'start' | 'end',\n  /**\n   * Where the Menu opens relative to its trigger.\n   *\n   * @default 'bottom'\n   */\n  direction?: 'bottom' | 'top' | 'left' | 'right' | 'start' | 'end',\n  /**\n   * Whether the menu should automatically flip direction when space is limited.\n   *\n   * @default true\n   */\n  shouldFlip?: boolean\n}\n\nexport interface MenuProps<T> extends Omit<AriaMenuProps<T>, 'children' | 'style' | 'className' | 'dependencies'>, StyleProps {\n  /**\n   * The size of the Menu.\n   *\n   * @default 'M'\n   */\n  size?: 'S' | 'M' | 'L' | 'XL',\n  /**\n   * The contents of the collection.\n   */\n  children?: ReactNode | ((item: T) => ReactNode)\n}\n\nexport const MenuContext = createContext<ContextValue<MenuProps<any>, DOMRefValue<HTMLDivElement>>>(null);\n\nexport let menu = style({\n  outlineStyle: 'none',\n  display: 'grid',\n  gridTemplateColumns: {\n    size: {\n      S: [edgeToText(24), 'auto', 'auto', 'minmax(0, 1fr)', 'auto', 'auto', 'auto', edgeToText(24)],\n      M: [edgeToText(32), 'auto', 'auto', 'minmax(0, 1fr)', 'auto', 'auto', 'auto', edgeToText(32)],\n      L: [edgeToText(40), 'auto', 'auto', 'minmax(0, 1fr)', 'auto', 'auto', 'auto', edgeToText(40)],\n      XL: [edgeToText(48), 'auto', 'auto', 'minmax(0, 1fr)', 'auto', 'auto', 'auto', edgeToText(48)]\n    }\n  },\n  boxSizing: 'border-box',\n  maxHeight: '[inherit]',\n  overflow: {\n    isPopover: 'auto'\n  },\n  maxWidth: {\n    isPopover: 320\n  },\n  padding: {\n    isPopover: 8\n  },\n  fontFamily: 'sans',\n  fontSize: 'control'\n}, getAllowedOverrides());\n\nexport let section = style({\n  gridColumnStart: 1,\n  gridColumnEnd: -1,\n  alignItems: 'center',\n  display: 'grid',\n  gridTemplateAreas: [\n    '. checkmark icon label       value keyboard descriptor .',\n    '. .         .    description .     .        .          .'\n  ],\n  gridTemplateColumns: 'subgrid'\n});\n\nexport let sectionHeader = style<{size?: 'S' | 'M' | 'L' | 'XL'}>({\n  color: 'neutral',\n  gridColumnStart: 2,\n  gridColumnEnd: -2,\n  boxSizing: 'border-box',\n  minHeight: 'control',\n  paddingY: centerPadding()\n});\n\nexport let sectionHeading = style({\n  font: 'ui',\n  fontWeight: 'bold',\n  margin: 0\n});\n\nexport let menuitem = style({\n  ...focusRing(),\n  boxSizing: 'border-box',\n  borderRadius: 'control',\n  font: 'control',\n  '--labelPadding': {\n    type: 'paddingTop',\n    value: centerPadding()\n  },\n  paddingBottom: '--labelPadding',\n  backgroundColor: { // TODO: revisit color when I have access to dev mode again\n    default: {\n      default: 'transparent',\n      isFocused: baseColor('gray-100').isFocusVisible\n    }\n  },\n  color: {\n    default: 'neutral',\n    isDisabled: {\n      default: 'disabled',\n      forcedColors: 'GrayText'\n    }\n  },\n  position: 'relative',\n  // each menu item should take up the entire width, the subgrid will handle within the item\n  gridColumnStart: 1,\n  gridColumnEnd: -1,\n  display: 'grid',\n  gridTemplateAreas: [\n    '. checkmark icon label       value keyboard descriptor .',\n    '. .         .    description .     .        .          .'\n  ],\n  gridTemplateColumns: 'subgrid',\n  gridTemplateRows: {\n    // min-content prevents second row from 'auto'ing to a size larger then 0 when empty\n    default: 'auto minmax(0, min-content)',\n    ':has([slot=description])': 'auto auto'\n  },\n  rowGap: {\n    ':has([slot=description])': space(1)\n  },\n  alignItems: 'baseline',\n  minHeight: 'control',\n  textDecoration: 'none',\n  cursor: {\n    default: 'default',\n    isLink: 'pointer'\n  },\n  transition: 'default'\n}, getAllowedOverrides());\n\nexport let checkmark = style({\n  visibility: {\n    default: 'hidden',\n    isSelected: 'visible'\n  },\n  gridArea: 'checkmark',\n  color: 'accent',\n  '--iconPrimary': {\n    type: 'fill',\n    value: {\n      default: 'currentColor',\n      forcedColors: 'Highlight'\n    }\n  },\n  marginEnd: 'text-to-control',\n  aspectRatio: 'square'\n});\n\nlet checkbox = style({\n  gridArea: 'checkmark',\n  marginEnd: 'text-to-control'\n});\n\nexport let icon = style({\n  display: 'block',\n  size: fontRelative(20),\n  // too small default icon size is wrong, it's like the icons are 1 tshirt size bigger than the rest of the component? check again after typography changes\n  // reminder, size of WF is applied via font size\n  marginEnd: 'text-to-visual',\n  '--iconPrimary': {\n    type: 'fill',\n    value: 'currentColor'\n  }\n});\n\nexport let iconCenterWrapper = style({\n  display: 'flex',\n  gridArea: 'icon'\n});\n\nlet image = style({\n  gridArea: 'icon',\n  gridRowEnd: 'span 2',\n  marginEnd: 'text-to-visual',\n  marginTop: fontRelative(6), // made up, need feedback\n  alignSelf: 'center',\n  borderRadius: 'sm',\n  size: {\n    default: 40,\n    size: {\n      S: 32,\n      M: 40,\n      L: 44,\n      XL: 48 // TODO: feedback, Why is it 50x50, that's on 12.25 so doesn't fit the grid at all\n    }\n  },\n  aspectRatio: 'square',\n  objectFit: 'contain'\n});\n\nexport let label = style<{size: string}>({\n  gridArea: 'label',\n  font: 'control',\n  color: '[inherit]',\n  fontWeight: 'medium',\n  // TODO: token values for padding not defined yet, revisit\n  marginTop: '--labelPadding'\n});\n\nexport let description = style({\n  gridArea: 'description',\n  font: {\n    default: 'ui-sm',\n    size: {\n      S: 'ui-xs',\n      M: 'ui-sm',\n      L: 'ui',\n      XL: 'ui-lg'\n    }\n  },\n  color: {\n    default: 'neutral-subdued',\n    // Ideally this would use the same token as hover, but we don't have access to that here.\n    // TODO: should we always consider isHovered and isFocused to be the same thing?\n    isFocused: 'gray-800',\n    isDisabled: 'disabled'\n  },\n  transition: 'default'\n});\n\nlet value = style({\n  gridArea: 'value',\n  marginStart: 8\n});\n\nlet keyboard = style({\n  gridArea: 'keyboard',\n  marginStart: 8,\n  font: 'ui',\n  fontWeight: 'light',\n  color: {\n    default: 'gray-600',\n    isDisabled: 'disabled',\n    forcedColors: {\n      isDisabled: 'GrayText'\n    }\n  },\n  background: 'gray-25',\n  unicodeBidi: 'plaintext'\n});\n\nlet descriptor = style({\n  gridArea: 'descriptor',\n  marginStart: 8,\n  '--iconPrimary': {\n    type: 'fill',\n    value: 'currentColor'\n  }\n});\n\nlet InternalMenuContext = createContext<{size: 'S' | 'M' | 'L' | 'XL', isSubmenu: boolean}>({size: 'M', isSubmenu: false});\nlet InternalMenuTriggerContext = createContext<Omit<MenuTriggerProps, 'children'> | null>(null);\n\n/**\n * Menus display a list of actions or options that a user can choose.\n */\nexport const Menu = /*#__PURE__*/ (forwardRef as forwardRefType)(function Menu<T extends object>(props: MenuProps<T>, ref: DOMRef<HTMLDivElement>) {\n  [props, ref] = useSpectrumContextProps(props, ref, MenuContext);\n  let {isSubmenu, size: ctxSize} = useContext(InternalMenuContext);\n  let {\n    children,\n    size = ctxSize,\n    UNSAFE_style,\n    UNSAFE_className,\n    styles\n  } = props;\n  let ctx = useContext(InternalMenuTriggerContext);\n  let {align = 'start', direction = 'bottom', shouldFlip} = ctx ?? {};\n\n  // TODO: change offset/crossoffset based on size? scale?\n  // actual values?\n  let initialPlacement: Placement;\n  switch (direction) {\n    case 'left':\n    case 'right':\n    case 'start':\n    case 'end':\n      initialPlacement = `${direction} ${align === 'end' ? 'bottom' : 'top'}` as Placement;\n      break;\n    case 'bottom':\n    case 'top':\n    default:\n      initialPlacement = `${direction} ${align}` as Placement;\n  }\n  if (isSubmenu) {\n    initialPlacement = 'end top' as Placement;\n  }\n\n  let content = (\n    <InternalMenuContext.Provider value={{size, isSubmenu: true}}>\n      <Provider\n        values={[\n          [HeaderContext, {styles: sectionHeader({size})}],\n          [HeadingContext, {styles: sectionHeading}],\n          [TextContext, {\n            slots: {\n              'description': {styles: description({size})}\n            }\n          }]\n        ]}>\n        <AriaMenu\n          {...props}\n          className={menu({size, isPopover: !!ctx || isSubmenu}, ctx ? null : styles)}>\n          {children}\n        </AriaMenu>\n      </Provider>\n    </InternalMenuContext.Provider>\n  );\n\n  if (ctx || isSubmenu) {\n    return (\n      <PopoverBase\n        ref={ref}\n        hideArrow\n        placement={initialPlacement}\n        shouldFlip={shouldFlip}\n        // For submenus, the offset from the edge of the popover should be 10px.\n        // Subtract 8px for the padding around the parent menu.\n        offset={isSubmenu ? -2 : 8}\n        // Offset by padding + border so that the first item in a submenu lines up with the parent menu item.\n        crossOffset={isSubmenu ? -9 : 0}\n        UNSAFE_style={UNSAFE_style}\n        UNSAFE_className={UNSAFE_className}\n        styles={styles}>\n        {content}\n      </PopoverBase>\n    );\n  }\n\n  return content;\n});\n\nexport function Divider(props: SeparatorProps) {\n  return (\n    <Separator\n      {...props}\n      className={mergeStyles(\n        divider({\n          size: 'M',\n          orientation: 'horizontal',\n          staticColor: undefined\n        }), style({\n          display: {\n            default: 'grid',\n            ':last-child': 'none'\n          },\n          gridColumnStart: 2,\n          gridColumnEnd: -2,\n          marginY: size(5) // height of the menu separator is 12px, and the divider is 2px\n        })\n      )} />\n  );\n}\n\nexport interface MenuSectionProps<T extends object> extends AriaMenuSectionProps<T> {}\nexport function MenuSection<T extends object>(props: MenuSectionProps<T>) {\n  // remember, context doesn't work if it's around Section nor inside\n  return (\n    <>\n      <AriaMenuSection\n        {...props}\n        className={section}>\n        {props.children}\n      </AriaMenuSection>\n      <Divider />\n    </>\n  );\n}\n\nexport interface MenuItemProps extends Omit<AriaMenuItemProps, 'children' | 'style' | 'className'>, StyleProps {\n  /**\n   * The contents of the item.\n   */\n  children: ReactNode\n}\n\nconst checkmarkIconSize = {\n  S: 'XS',\n  M: 'M',\n  L: 'L',\n  XL: 'XL'\n} as const;\n\nconst linkIconSize = {\n  S: 'M',\n  M: 'L',\n  L: 'XL',\n  XL: 'XL'\n} as const;\n\nexport function MenuItem(props: MenuItemProps) {\n  let ref = useRef(null);\n  let isLink = props.href != null;\n  let isLinkOut = isLink && props.target === '_blank';\n  let {size} = useContext(InternalMenuContext);\n  let textValue = props.textValue || (typeof props.children === 'string' ? props.children : undefined);\n  let {direction} = useLocale();\n  return (\n    <AriaMenuItem\n      {...props}\n      textValue={textValue}\n      ref={ref}\n      style={pressScale(ref, props.UNSAFE_style)}\n      className={renderProps => (props.UNSAFE_className || '') + menuitem({...renderProps, isFocused: (renderProps.hasSubmenu && renderProps.isOpen) || renderProps.isFocused, size, isLink}, props.styles)}>\n      {(renderProps) => {\n        let {children} = props;\n        let checkboxRenderProps = {...renderProps, size, isFocused: false, isFocusVisible: false, isIndeterminate: false, isReadOnly: false, isInvalid: false, isRequired: false};\n        return (\n          <>\n            <Provider\n              values={[\n                [IconContext, {\n                  slots: {\n                    icon: {render: centerBaseline({slot: 'icon', styles: iconCenterWrapper}), styles: icon},\n                    descriptor: {render: centerBaseline({slot: 'descriptor', styles: descriptor})} // TODO: remove once we have default?\n                  }\n                }],\n                [TextContext, {\n                  slots: {\n                    label: {styles: label({size})},\n                    description: {styles: description({...renderProps, size})},\n                    value: {styles: value}\n                  }\n                }],\n                [KeyboardContext, {styles: keyboard({size, isDisabled: renderProps.isDisabled})}],\n                [ImageContext, {styles: image({size})}]\n              ]}>\n              {renderProps.selectionMode === 'single' && !isLink && !renderProps.hasSubmenu && <CheckmarkIcon size={checkmarkIconSize[size]} className={checkmark({...renderProps, size})} />}\n              {renderProps.selectionMode === 'multiple' && !isLink && !renderProps.hasSubmenu && (\n                <div className={mergeStyles(checkbox, box(checkboxRenderProps))}>\n                  <CheckmarkIcon size={size} className={iconStyles} />\n                </div>\n              )}\n              {typeof children === 'string' ? <Text slot=\"label\">{children}</Text> : children}\n              {isLinkOut && <LinkOutIcon size={linkIconSize[size]} className={descriptor} />}\n              {renderProps.hasSubmenu && (\n                <div slot=\"descriptor\" className={descriptor}>\n                  <ChevronRightIcon\n                    size={size}\n                    className={style({\n                      scale: {\n                        direction: {\n                          rtl: -1\n                        }\n                      }\n                    })({direction})} />\n                </div>\n              )}\n            </Provider>\n          </>\n        );\n      }}\n    </AriaMenuItem>\n  );\n}\n\n/**\n * The MenuTrigger serves as a wrapper around a Menu and its associated trigger,\n * linking the Menu's open state with the trigger's press state.\n */\nfunction MenuTrigger(props: MenuTriggerProps) {\n  return (\n    <InternalMenuTriggerContext.Provider\n      value={{\n        align: props.align,\n        direction: props.direction,\n        shouldFlip: props.shouldFlip\n      }}>\n      <AriaMenuTrigger {...props}>\n        {/* RAC sets isPressed via PressResponder when the menu is open.\n            We don't want press scaling to appear to get \"stuck\", so override this. */}\n        <PressResponder isPressed={false}>\n          {props.children}\n        </PressResponder>\n      </AriaMenuTrigger>\n    </InternalMenuTriggerContext.Provider>\n  );\n}\n\nexport interface SubmenuTriggerProps extends Omit<AriaSubmenuTriggerProps, 'delay'> {}\n\nconst SubmenuTrigger = AriaSubmenuTrigger as (props: SubmenuTriggerProps) => JSX.Element | null;\n\nexport {MenuTrigger, SubmenuTrigger};\n\n// This is purely so that storybook generates the types for both Menu and MenuTrigger\ninterface ICombined<T extends object> extends MenuProps<T>, Omit<MenuTriggerProps, 'children'> {}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function CombinedMenu<T extends object>(props: ICombined<T>) {\n  return <div />;\n}\n"],"names":[],"version":3,"file":"Menu.css.map"}