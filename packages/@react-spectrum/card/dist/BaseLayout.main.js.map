{"mappings":"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","sources":["packages/@react-spectrum/card/src/BaseLayout.tsx"],"sourcesContent":["// @ts-nocheck\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Direction, Key, KeyboardDelegate, Node} from '@react-types/shared';\nimport {getChildNodes, getFirstItem} from '@react-stately/collections';\nimport {GridCollection} from '@react-stately/grid';\nimport {InvalidationContext, Layout, LayoutInfo, Rect, Size} from '@react-stately/virtualizer';\nimport {Scale} from '@react-types/provider';\n\nexport interface BaseLayoutOptions {\n  collator?: Intl.Collator,\n  // TODO: is this valid or is scale a spectrum specific thing that should be left out of the layouts?\n  scale?: Scale,\n  /**\n   * The margin around the grid view between the edges and the items.\n   * @default 24\n   */\n  margin?: number\n}\n\ninterface CardViewLayoutOptions {\n  isLoading: boolean,\n  direction: Direction\n}\n\nexport class BaseLayout<T> extends Layout<Node<T>, CardViewLayoutOptions> implements KeyboardDelegate {\n  protected contentSize: Size;\n  protected layoutInfos: Map<Key, LayoutInfo>;\n  protected collator: Intl.Collator;\n  protected lastCollection: GridCollection<T>;\n  collection:  GridCollection<T>;\n  isLoading: boolean;\n  disabledKeys: Set<Key> = new Set();\n  direction: Direction;\n  scale: Scale;\n  margin: number;\n\n  constructor(options: BaseLayoutOptions = {}) {\n    super();\n    this.layoutInfos = new Map();\n    this.collator = options.collator;\n    this.lastCollection = null;\n    this.scale = options.scale || 'medium';\n    this.margin = options.margin || 24;\n  }\n\n  update(invalidationContext: InvalidationContext<CardViewLayoutOptions>) {\n    this.collection = this.virtualizer.collection as GridCollection<T>;\n    this.isLoading = invalidationContext.layoutOptions?.isLoading || false;\n    this.direction = invalidationContext.layoutOptions?.direction || 'ltr';\n    this.buildCollection(invalidationContext);\n\n    // Remove layout info that doesn't exist in new collection\n    if (this.lastCollection) {\n      for (let key of this.lastCollection.getKeys()) {\n        if (!this.collection.getItem(key)) {\n          this.layoutInfos.delete(key);\n        }\n      }\n\n      if (!this.isLoading) {\n        this.layoutInfos.delete('loader');\n      }\n\n      if (this.collection.size > 0) {\n        this.layoutInfos.delete('placeholder');\n      }\n    }\n\n    this.lastCollection = this.collection;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  buildCollection(invalidationContext?: InvalidationContext) {}\n\n  getContentSize() {\n    return this.contentSize;\n  }\n\n  getLayoutInfo(key: Key) {\n    return this.layoutInfos.get(key)!;\n  }\n\n  getVisibleLayoutInfos(rect: Rect, excludePersistedKeys = false) {\n    let res: LayoutInfo[] = [];\n\n    for (let layoutInfo of this.layoutInfos.values()) {\n      if (this.isVisible(layoutInfo, rect, excludePersistedKeys)) {\n        res.push(layoutInfo);\n      }\n    }\n\n    return res;\n  }\n\n  isVisible(layoutInfo: LayoutInfo, rect: Rect, excludePersistedKeys: boolean) {\n    if (layoutInfo.rect.intersects(rect)) {\n      return true;\n    }\n\n    if (!excludePersistedKeys) {\n      return this.virtualizer.isPersistedKey(layoutInfo.key);\n    }\n\n    return false;\n  }\n\n  _findClosestLayoutInfo(target: Rect, rect: Rect) {\n    let layoutInfos = this.getVisibleLayoutInfos(rect, true);\n    let best = null;\n    let bestDistance = Infinity;\n\n    // Calculates distance as the distance between the center of 2 rects.\n    for (let cur of layoutInfos) {\n      if (cur.type === 'item') {\n        let curRect = cur.rect;\n        let targetMidX = (target.x + target.maxX) / 2;\n        let targetMidY = (target.y + target.maxY) / 2;\n        let curMidX = (curRect.x + curRect.maxX) / 2;\n        let curMidY = (curRect.y + curRect.maxY) / 2;\n        let dist = Math.pow(targetMidX - curMidX, 2) + Math.pow(targetMidY - curMidY, 2);\n        if (dist < bestDistance) {\n          best = cur;\n          bestDistance = dist;\n        }\n      }\n    }\n\n    return best;\n  }\n\n  _findClosest(target: Rect, rect: Rect) {\n    let best = this._findClosestLayoutInfo(target, rect);\n    return best || null;\n  }\n\n  getKeyBelow(key: Key) {\n    // Expected key is the currently focused cell so we need the parent row key\n    let parentRowKey = this.collection.getItem(key).parentKey;\n    let layoutInfo = this.getLayoutInfo(parentRowKey);\n    let rect = new Rect(layoutInfo.rect.x, layoutInfo.rect.maxY + 1, layoutInfo.rect.width, this.virtualizer.visibleRect.height);\n    let closestRow = this.collection.getItem(this._findClosest(layoutInfo.rect, rect)?.key);\n    return getFirstItem(getChildNodes(closestRow, this.collection))?.key;\n  }\n\n  getKeyAbove(key: Key) {\n    // Expected key is the currently focused cell so we need the parent row key\n    let parentRowKey = this.collection.getItem(key).parentKey;\n    let layoutInfo = this.getLayoutInfo(parentRowKey);\n    let rect = new Rect(layoutInfo.rect.x, 0, layoutInfo.rect.width, layoutInfo.rect.y - 1);\n    let closestRow = this.collection.getItem(this._findClosest(layoutInfo.rect, rect)?.key);\n    return getFirstItem(getChildNodes(closestRow, this.collection))?.key;\n  }\n\n  getKeyRightOf(key: Key) {\n    // Expected key is the currently focused cell so we need the parent row key\n    let parentRowKey = this.collection.getItem(key).parentKey;\n    key = this.direction === 'rtl' ?  this.collection.getKeyBefore(parentRowKey) : this.collection.getKeyAfter(parentRowKey);\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      // Don't check if item is disabled because we want to be able to focus disabled items in a grid (double check this)\n      if (item.type === 'item') {\n        return getFirstItem(getChildNodes(item, this.collection))?.key;\n      }\n      key = this.direction === 'rtl' ?  this.collection.getKeyBefore(key) : this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyLeftOf(key: Key) {\n    // Expected key is the currently focused cell so we need the parent row key\n    let parentRowKey = this.collection.getItem(key).parentKey;\n    key = this.direction === 'rtl' ?  this.collection.getKeyAfter(parentRowKey) : this.collection.getKeyBefore(parentRowKey);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      // Don't check if item is disabled because we want to be able to focus disabled items in a grid (double check this)\n      if (item.type === 'item') {\n        return getFirstItem(getChildNodes(item, this.collection))?.key;\n      }\n\n      key = this.direction === 'rtl' ?  this.collection.getKeyAfter(key) : this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let firstRow = this.collection.getItem(this.collection.getFirstKey());\n    return getFirstItem(getChildNodes(firstRow, this.collection))?.key;\n  }\n\n  getLastKey() {\n    let lastRow = this.collection.getItem(this.collection.getLastKey());\n    return getFirstItem(getChildNodes(lastRow, this.collection))?.key;\n  }\n\n  // TODO: pretty unwieldy because it needs to bounce back and forth between the parent key and the child key\n  // Perhaps have layoutInfo store childKey as well so we don't need to do this? Or maybe make the layoutInfos be the cells instead of the rows?\n  getKeyPageAbove(key: Key) {\n    // Expected key is the currently focused cell so we need the parent row key\n    let parentRowKey = this.collection.getItem(key).parentKey;\n    let layoutInfo = this.getLayoutInfo(parentRowKey);\n\n    if (layoutInfo) {\n      let pageY = Math.max(0, layoutInfo.rect.y + layoutInfo.rect.height - this.virtualizer.visibleRect.height);\n      // If the node is so large that it spans multiple page heights, return the key of the item immediately above\n      // Otherwise keep going up until we exceed a single page height worth of nodes\n      let keyAbove = this.collection.getItem(this.getKeyAbove(key))?.parentKey;\n      layoutInfo = this.getLayoutInfo(keyAbove);\n\n      if (layoutInfo && layoutInfo.rect.y > pageY) {\n        while (layoutInfo && layoutInfo.rect.y > pageY) {\n          let childKey = getFirstItem(getChildNodes(this.collection.getItem(layoutInfo.key), this.collection))?.key;\n          let keyAbove = this.collection.getItem(this.getKeyAbove(childKey))?.parentKey;\n          layoutInfo = this.getLayoutInfo(keyAbove);\n        }\n      }\n\n      if (layoutInfo) {\n        let childKey = getFirstItem(getChildNodes(this.collection.getItem(layoutInfo.key), this.collection))?.key;\n        return childKey;\n      }\n    }\n\n    return this.getFirstKey();\n  }\n\n  // TODO: pretty unwieldy because it needs to bounce back and forth between the parent key and the child key\n  // Perhaps have layoutInfo store childKey as well so we don't need to do this?\n  getKeyPageBelow(key: Key) {\n    // Expected key is the currently focused cell so we need the parent row key\n    let parentRowKey = this.collection.getItem(key).parentKey;\n    let layoutInfo = this.getLayoutInfo(parentRowKey);\n    if (layoutInfo) {\n      let pageY = Math.min(this.virtualizer.contentSize.height, layoutInfo.rect.y - layoutInfo.rect.height + this.virtualizer.visibleRect.height);\n      // If the node is so large that it spans multiple page heights, return the key of the item immediately below\n      // Otherwise keep going up until we exceed a single page height worth of nodes\n      let keyBelow =  this.collection.getItem(this.getKeyBelow(key))?.parentKey;\n      layoutInfo = this.getLayoutInfo(keyBelow);\n      if (layoutInfo && layoutInfo.rect.y < pageY) {\n        while (layoutInfo && layoutInfo.rect.y < pageY) {\n          let childKey = getFirstItem(getChildNodes(this.collection.getItem(layoutInfo.key), this.collection))?.key;\n          let keyBelow = this.collection.getItem(this.getKeyBelow(childKey))?.parentKey;\n          layoutInfo = this.getLayoutInfo(keyBelow);\n        }\n      }\n\n      if (layoutInfo) {\n        let childKey = getFirstItem(getChildNodes(this.collection.getItem(layoutInfo.key), this.collection))?.key;\n        return childKey;\n      }\n    }\n\n    return this.getLastKey();\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey ?? this.getFirstKey();\n\n    let startItem = collection.getItem(key);\n    key = startItem.parentKey;\n\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          return getFirstItem(getChildNodes(item, this.collection))?.key;\n        }\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return null;\n  }\n}\n"],"names":[],"version":3,"file":"BaseLayout.main.js.map"}