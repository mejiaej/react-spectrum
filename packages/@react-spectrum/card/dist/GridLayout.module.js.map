{"mappings":"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","sources":["packages/@react-spectrum/card/src/GridLayout.tsx"],"sourcesContent":["// @ts-nocheck\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {BaseLayout, BaseLayoutOptions} from './BaseLayout';\nimport {getChildNodes, getFirstItem} from '@react-stately/collections';\nimport {Key, Node, Orientation} from '@react-types/shared';\nimport {LayoutInfo, Rect, Size} from '@react-stately/virtualizer';\n\nexport interface GridLayoutOptions extends BaseLayoutOptions {\n  // /**\n  //  * The card size in the grid.\n  //  */\n  // cardSize?: 'S' | 'M' | 'L',\n  /**\n   * The minimum item size.\n   * @default 208 x 208 for horizontal card orientation. 102 x 102 for vertical card orientation.\n   */\n  minItemSize?: Size,\n  /**\n   * The maximum item size.\n   * @default Infinity\n   */\n  maxItemSize?: Size,\n  /**\n   * The minimum space required between items.\n   * @default 18 x 18\n   */\n  minSpace?: Size,\n  /**\n   * The maximum number of columns.\n   * @default Infinity\n   */\n  maxColumns?: number,\n  /**\n   * The additional padding along the card's main axis. Affects the sizing of the content area following the card image.\n   * @default 95\n   */\n  itemPadding?: number,\n  /**\n   * The orientation of the cards withn the grid.\n   * @default vertical\n   */\n  cardOrientation?: Orientation\n}\n\nconst DEFAULT_OPTIONS = {\n  S: {\n    itemPadding: 20,\n    minItemSize: {\n      'vertical': new Size(96, 96)\n    },\n    maxItemSize: new Size(Infinity, Infinity),\n    margin: 8,\n    minSpace: new Size(6, 6),\n    maxColumns: Infinity,\n    dropSpacing: 50\n  },\n  L: {\n    itemPadding: {\n      'vertical': {\n        'medium': 78,\n        'large': 98\n      },\n      'horizontal': {\n        'medium': 150,\n        'large': 170\n      }\n    },\n    minItemSize: {\n      'vertical': new Size(208, 208),\n      'horizontal': new Size(102, 102)\n    },\n    maxItemSize: new Size(Infinity, Infinity),\n    margin: 24,\n    minSpace: new Size(18, 18),\n    maxColumns: Infinity,\n    dropSpacing: 100\n  }\n};\n\nexport class GridLayout<T> extends BaseLayout<T> {\n  protected minItemSize: Size;\n  protected maxItemSize: Size;\n  protected minSpace: Size;\n  protected maxColumns: number;\n  itemPadding: number;\n  cardOrientation: Orientation;\n  protected itemSize: Size;\n  protected numColumns: number;\n  protected numRows: number;\n  protected horizontalSpacing: number;\n\n  constructor(options: GridLayoutOptions = {}) {\n    super(options);\n    let cardSize = 'L';\n    this.cardOrientation = options.cardOrientation || 'vertical';\n    this.minItemSize = options.minItemSize || DEFAULT_OPTIONS[cardSize].minItemSize[this.cardOrientation];\n    this.maxItemSize = options.maxItemSize || DEFAULT_OPTIONS[cardSize].maxItemSize;\n    this.margin = options.margin != null ? options.margin : DEFAULT_OPTIONS[cardSize].margin;\n    this.minSpace = options.minSpace || DEFAULT_OPTIONS[cardSize].minSpace;\n    this.maxColumns = options.maxColumns || DEFAULT_OPTIONS[cardSize].maxColumns;\n    this.itemPadding = options.itemPadding != null ? options.itemPadding : DEFAULT_OPTIONS[cardSize].itemPadding[this.cardOrientation][this.scale];\n    this.itemSize = null;\n    this.numColumns = 0;\n    this.numRows = 0;\n    this.horizontalSpacing = 0;\n  }\n\n  get layoutType() {\n    return 'grid';\n  }\n\n  getIndexAtPoint(x, y, allowInsertingAtEnd = false) {\n    let itemHeight = this.itemSize.height + this.minSpace.height;\n    let itemWidth = this.itemSize.width + this.horizontalSpacing;\n    return Math.max(0,\n      Math.min(\n        this.collection.size - (allowInsertingAtEnd ? 0 : 1),\n        Math.floor(y / itemHeight) * this.numColumns + Math.floor((x - this.horizontalSpacing) / itemWidth)\n      )\n    );\n  }\n\n  buildCollection() {\n    let visibleWidth = this.virtualizer.visibleRect.width;\n    let visibleHeight = this.virtualizer.visibleRect.height;\n    let horizontalItemPadding = this.cardOrientation === 'horizontal' ? this.itemPadding : 0;\n    let verticalItemPadding = this.cardOrientation === 'vertical' ? this.itemPadding : 0;\n    let minCardWidth = this.minItemSize.width + horizontalItemPadding;\n\n    // Compute the number of rows and columns needed to display the content\n    let availableWidth = visibleWidth - this.margin * 2;\n    let columns = Math.floor((availableWidth + this.minSpace.width) / (minCardWidth + this.minSpace.width));\n    this.numColumns = Math.max(1, Math.min(this.maxColumns, columns));\n    this.numRows = Math.ceil(this.collection.size / this.numColumns);\n\n    // Compute the available width (minus the space between items)\n    let width = availableWidth - (this.minSpace.width * Math.max(0, this.numColumns - 1));\n\n    // Compute the item width based on the space available\n    let itemWidth = Math.floor(width / this.numColumns);\n    itemWidth = Math.max(minCardWidth, Math.min(this.maxItemSize.width, itemWidth));\n    // Compute the item height, which is proportional to the item width\n    let t = ((itemWidth - minCardWidth) / minCardWidth);\n    let itemHeight = Math.floor(this.minItemSize.height + this.minItemSize.height * t);\n    itemHeight = Math.max(this.minItemSize.height, Math.min(this.maxItemSize.height, itemHeight)) + verticalItemPadding;\n    this.itemSize = new Size(itemWidth, itemHeight);\n\n    // Compute the horizontal spacing and content height\n    this.horizontalSpacing = this.numColumns < 2 ? 0 : Math.floor((availableWidth - this.numColumns * this.itemSize.width) / (this.numColumns - 1));\n\n    let y = this.margin;\n    let index = 0;\n    for (let node of this.collection) {\n      let layoutInfo = this.buildChild(node, y, index);\n      y = layoutInfo.rect.maxY;\n      index++;\n    }\n\n    if (this.isLoading) {\n      let loaderY = y;\n      let loaderHeight = 60;\n      // If there aren't any items, make loader take all avaliable room and remove margin from y calculation\n      // so it doesn't scroll\n      if (this.collection.size === 0) {\n        loaderY = 0;\n        loaderHeight = visibleHeight || 60;\n      }\n\n      let rect = new Rect(0, loaderY, visibleWidth, loaderHeight);\n      let loader = new LayoutInfo('loader', 'loader', rect);\n      this.layoutInfos.set('loader', loader);\n      y = loader.rect.maxY;\n    }\n\n    if (this.collection.size === 0 && !this.isLoading) {\n      let rect = new Rect(0, 0, visibleWidth, visibleHeight);\n      let placeholder = new LayoutInfo('placeholder', 'placeholder', rect);\n      this.layoutInfos.set('placeholder', placeholder);\n      y = placeholder.rect.maxY;\n    }\n\n    this.contentSize = new Size(visibleWidth, y);\n  }\n\n  buildChild(node: Node<T>, y: number, index: number): LayoutInfo {\n    let row = Math.floor(index / this.numColumns);\n    let column = index % this.numColumns;\n    let x = this.margin + column * (this.itemSize.width + this.horizontalSpacing);\n    y = this.margin + row * (this.itemSize.height + this.minSpace.height);\n\n    let rect = new Rect(x, y, this.itemSize.width, this.itemSize.height);\n    // TODO: Perhaps have it so that the child key for each row is stored with the layoutInfo?\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.allowOverflow = true;\n    this.layoutInfos.set(node.key, layoutInfo);\n    return layoutInfo;\n  }\n\n  // Since the collection doesn't represent the visual layout, need to calculate what row and column the current key is in,\n  // then return the key that occupies the row + column below. This can be done by figuring out how many cards exist per column then dividing the\n  // collection contents by that number (which will give us the row distribution)\n  getKeyBelow(key: Key) {\n    // Expected key is the currently focused cell so we need the parent row key\n    let parentRowKey = this.collection.getItem(key).parentKey;\n    let indexRowBelow;\n    let index = this.collection.rows.findIndex(card => card.key === parentRowKey);\n    if (index !== -1) {\n      indexRowBelow = index + this.numColumns;\n    } else {\n      return null;\n    }\n\n    let row = this.collection.rows[indexRowBelow];\n    return row ? getFirstItem(getChildNodes(row, this.collection))?.key : null;\n  }\n\n  getKeyAbove(key: Key) {\n    // Expected key is the currently focused cell so we need the parent row key\n    let parentRowKey = this.collection.getItem(key).parentKey;\n    let indexRowAbove;\n    let index = this.collection.rows.findIndex(card => card.key === parentRowKey);\n    if (index !== -1) {\n      indexRowAbove = index - this.numColumns;\n    } else {\n      return null;\n    }\n\n    let row = this.collection.rows[indexRowAbove];\n    return row ? getFirstItem(getChildNodes(row, this.collection))?.key : null;\n  }\n}\n"],"names":[],"version":3,"file":"GridLayout.module.js.map"}