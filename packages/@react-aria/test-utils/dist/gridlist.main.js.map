{"mappings":";;;;;;;;;AAAA;;;;;;;;;;CAUC;;AASM,MAAM;IA+EX,wGAAwG;IACxG,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,SAAS;IACvB;IAEA,IAAI,OAAO;YACK;QAAd,OAAO,CAAA,GAAA,iCAAK,GAAE,QAAA,IAAI,cAAJ,4BAAA,MAAM,QAAQ,EAAE,cAAc,CAAC;IAC/C;IAEA,IAAI,eAAe;QACjB,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA,MAAO,IAAI,YAAY,CAAC,qBAAqB;IACvE;IApFA,YAAY,IAAqB,CAAE;aAOnC,qBAAqB,CAAC;YACpB,IAAI,CAAC,gBAAgB,GAAG;QAC1B;QAEA,+GAA+G;QAC/G,6IAA6I;QAC7I,kHAAkH;QAClH,0HAA0H;QAC1H,oDAAoD;aACpD,qBAAqB,OAAO,OAAuF,CAAC,CAAC;YACnH,IAAI,SAAC,KAAK,QAAE,IAAI,mBAAE,kBAAkB,IAAI,CAAC,gBAAgB,EAAC,GAAG;YAE7D,IAAI,MAAM,IAAI,CAAC,OAAO,CAAC;uBAAC;sBAAO;YAAI;YACnC,IAAI,cAAc,CAAA,GAAA,iCAAK,EAAE,KAAK,WAAW,CAAC;YAC1C,IAAI,aACF,MAAM,CAAA,GAAA,sCAAW,EAAE,IAAI,CAAC,IAAI,EAAE,aAAa;iBACtC;gBACL,IAAI,OAAO,CAAA,GAAA,iCAAK,EAAE,KAAK,YAAY,CAAC,WAAW,CAAC,EAAE;gBAClD,MAAM,CAAA,GAAA,sCAAW,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM;YACtC;QACF;QAEA,2HAA2H;QAC3H,cAAc;aACd,UAAU,CAAC;YACT,IAAI,SACF,KAAK,QACL,IAAI,EACL,GAAG;YAEJ,IAAI;YACJ,IAAI,SAAS,MACX,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM;iBACjB,IAAI,QAAQ,MAAM;oBACV;gBAAb,MAAM,CAAA,GAAA,iCAAK,GAAE,QAAA,IAAI,cAAJ,4BAAA,MAAM,QAAQ,EAAE,SAAS,CAAC;gBACvC,MAAO,OAAO,IAAI,YAAY,CAAC,YAAY,MACzC,MAAM,IAAI,aAAa;YAE3B;YAEA,OAAO;QACT;QAEA,0IAA0I;QAC1I,4BAA4B;aAC5B,mBAAmB,OAAO;YACxB,IAAI,SACF,KAAK,QACL,IAAI,oBACJ,gBAAgB,mBAChB,kBAAkB,IAAI,CAAC,gBAAgB,EACxC,GAAG;YAEJ,IAAI,MAAM,IAAI,CAAC,OAAO,CAAC;uBAAC;sBAAO;YAAI;YACnC,IAAI,KAAK;gBACP,IAAI,kBACF,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;qBACpB,IAAI,oBAAoB,YAAY;oBACzC,CAAA,GAAA,8BAAE,EAAE,IAAM,IAAI,KAAK;oBACnB,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;gBAC3B,OACE,MAAM,CAAA,GAAA,sCAAW,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK;YAEvC;QACF;aAeA,QAAQ,CAAC,OAAgC,CAAC,CAAC;YACzC,IAAI,WAAC,OAAO,EAAC,GAAG;YAChB,OAAO,CAAA,GAAA,iCAAK,EAAE,WAAW,IAAI,CAAC,QAAQ,EAAE,cAAc,CAAC;QACzD;QAxFE,IAAI,QAAC,IAAI,QAAE,IAAI,mBAAE,eAAe,EAAC,GAAG;QACpC,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,gBAAgB,GAAG,mBAAmB;QAC3C,IAAI,CAAC,SAAS,GAAG;IACnB;AAqFF","sources":["packages/@react-aria/test-utils/src/gridlist.ts"],"sourcesContent":["/*\n * Copyright 2024 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {act, within} from '@testing-library/react';\nimport {BaseTesterOpts, UserOpts} from './user';\nimport {pressElement} from './events';\n\nexport interface GridListOptions extends UserOpts, BaseTesterOpts {\n  user?: any\n}\nexport class GridListTester {\n  private user;\n  private _interactionType: UserOpts['interactionType'];\n  private _gridlist: HTMLElement;\n\n\n  constructor(opts: GridListOptions) {\n    let {root, user, interactionType} = opts;\n    this.user = user;\n    this._interactionType = interactionType || 'mouse';\n    this._gridlist = root;\n  }\n\n  setInteractionType = (type: UserOpts['interactionType']) => {\n    this._interactionType = type;\n  };\n\n  // TODO: support long press? This is also pretty much the same as table's toggleRowSelection so maybe can share\n  // For now, don't include long press, see if people need it or if we should just expose long press as a separate util if it isn't very common\n  // If the current way of passing in the user specified advance timers is ok, then I'd be find including long press\n  // Maybe also support an option to force the click to happen on a specific part of the element (checkbox or row). That way\n  // the user can test a specific type of interaction?\n  toggleRowSelection = async (opts: {index?: number, text?: string, interactionType?: UserOpts['interactionType']} = {}) => {\n    let {index, text, interactionType = this._interactionType} = opts;\n\n    let row = this.findRow({index, text});\n    let rowCheckbox = within(row).queryByRole('checkbox');\n    if (rowCheckbox) {\n      await pressElement(this.user, rowCheckbox, interactionType);\n    } else {\n      let cell = within(row).getAllByRole('gridcell')[0];\n      await pressElement(this.user, cell, interactionType);\n    }\n  };\n\n  // TODO: pretty much the same as table except it uses this.gridlist. Make common between the two by accepting an option for\n  // an element?\n  findRow = (opts: {index?: number, text?: string}) => {\n    let {\n      index,\n      text\n    } = opts;\n\n    let row;\n    if (index != null) {\n      row = this.rows[index];\n    } else if (text != null) {\n      row = within(this?.gridlist).getByText(text);\n      while (row && row.getAttribute('role') !== 'row') {\n        row = row.parentElement;\n      }\n    }\n\n    return row;\n  };\n\n  // TODO: There is a more difficult use case where the row has/behaves as link, don't think we have a good way to determine that unless the\n  // user specificlly tells us\n  triggerRowAction = async (opts: {index?: number, text?: string, needsDoubleClick?: boolean, interactionType?: UserOpts['interactionType']}) => {\n    let {\n      index,\n      text,\n      needsDoubleClick,\n      interactionType = this._interactionType\n    } = opts;\n\n    let row = this.findRow({index, text});\n    if (row) {\n      if (needsDoubleClick) {\n        await this.user.dblClick(row);\n      } else if (interactionType === 'keyboard') {\n        act(() => row.focus());\n        await this.user.keyboard('[Enter]');\n      } else {\n        await pressElement(this.user, row, interactionType);\n      }\n    }\n  };\n\n  // TODO: do we really need this getter? Theoretically the user already has the reference to the gridlist\n  get gridlist() {\n    return this._gridlist;\n  }\n\n  get rows() {\n    return within(this?.gridlist).queryAllByRole('row');\n  }\n\n  get selectedRows() {\n    return this.rows.filter(row => row.getAttribute('aria-selected') === 'true');\n  }\n\n  cells = (opts: {element?: HTMLElement} = {}) => {\n    let {element} = opts;\n    return within(element || this.gridlist).queryAllByRole('gridcell');\n  };\n}\n"],"names":[],"version":3,"file":"gridlist.main.js.map"}