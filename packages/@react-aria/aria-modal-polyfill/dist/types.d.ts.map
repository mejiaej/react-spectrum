{"mappings":"AAcA,cAAc,MAAM,IAAI,CAAC;AAIzB;;GAEG;AACH,4BAA4B,QAAQ,GAAC,MAAe,EAAE,EAAC,QAA0B,EAAC;;CAAK,GAAG,MAAM,CAsD/F","sources":["packages/@react-aria/aria-modal-polyfill/src/packages/@react-aria/aria-modal-polyfill/src/index.ts","packages/@react-aria/aria-modal-polyfill/src/index.ts"],"sourcesContent":[null,"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {hideOthers} from 'aria-hidden';\n\ntype Revert = () => void;\n\nconst currentDocument = typeof document !== 'undefined' ? document : undefined;\n\n/**\n * Acts as a polyfill for `aria-modal` by watching for added modals and hiding any surrounding DOM elements with `aria-hidden`.\n */\nexport function watchModals(selector:string = 'body', {document = currentDocument} = {}): Revert {\n  /**\n   * Listen for additions to the child list of the selected element (defaults to body). This is where providers render modal portals.\n   * When one is added, see if there is a modal inside it, if there is, then hide everything else from screen readers.\n   * If there was already a modal open and a new one was added, undo everything that the previous modal had hidden and hide based on the new one.\n   *\n   * If a modal container is removed, then undo the hiding based on the last hide others. Check if there are any other modals still around, and\n   * hide based on the last one added.\n   */\n  if (!document) {\n    return () => {};\n  }\n  let target = document.querySelector(selector);\n  if (!target) {\n    return () => {};\n  }\n  let config = {childList: true};\n  let modalContainers: Array<Element> = [];\n  let undo: Revert | undefined;\n\n  let observer = new MutationObserver((mutationRecord) => {\n    const liveAnnouncer =  document.querySelector('[data-live-announcer=\"true\"]');\n    for (let mutation of mutationRecord) {\n      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n        let addNode: Element = (Array.from(mutation.addedNodes).find((node: any) => node.querySelector?.('[aria-modal=\"true\"], [data-ismodal=\"true\"]')) as HTMLElement);\n        if (addNode) {\n          modalContainers.push(addNode);\n          let modal = addNode.querySelector('[aria-modal=\"true\"], [data-ismodal=\"true\"]') as HTMLElement;\n          undo?.();\n          let others = [modal, ... liveAnnouncer ? [liveAnnouncer as HTMLElement] : []];\n          undo = hideOthers(others);\n        }\n      } else if (mutation.type === 'childList' && mutation.removedNodes.length > 0) {\n        let removedNodes = Array.from(mutation.removedNodes);\n        let nodeIndexRemove = modalContainers.findIndex(container => removedNodes.includes(container));\n        if (nodeIndexRemove >= 0) {\n          undo?.();\n          modalContainers = modalContainers.filter((val, i) => i !== nodeIndexRemove);\n          if (modalContainers.length > 0) {\n            let modal = modalContainers[modalContainers.length - 1].querySelector('[aria-modal=\"true\"], [data-ismodal=\"true\"]') as HTMLElement;\n            let others = [modal, ... liveAnnouncer ? [liveAnnouncer as HTMLElement] : []];\n            undo = hideOthers(others);\n          } else {\n            undo = undefined;\n          }\n        }\n      }\n    }\n  });\n  observer.observe(target, config);\n  return () => {\n    undo?.();\n    observer.disconnect();\n  };\n}\n"],"names":[],"version":3,"file":"types.d.ts.map"}